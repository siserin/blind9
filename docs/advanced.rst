.. Advanced:

Advanced DNS Features
=====================

Notify
------

DNS NOTIFY is a mechanism that allows master servers to notify their
slave servers of changes to a zone's data. In response to a ``NOTIFY``
from a master server, the slave will check to see that its version of
the zone is the current version and, if not, initiate a zone transfer.

For more information about DNS ``NOTIFY``, see the description of the
``notify`` option in `Boolean Options <#boolean_options>`__ and the
description of the zone option ``also-notify`` in `Zone
Transfers <#zone_transfers>`__. The ``NOTIFY`` protocol is specified in
RFC 1996.

   **Note**

   As a slave zone can also be a master to other slaves, ``named``, by
   default, sends ``NOTIFY`` messages for every zone it loads.
   Specifying ``notify master-only;`` will cause ``named`` to only send
   ``NOTIFY`` for master zones that it loads.

.. _dynamic_update:

Dynamic Update
--------------

Dynamic Update is a method for adding, replacing or deleting records in
a master server by sending it a special form of DNS messages. The format
and meaning of these messages is specified in RFC 2136.

Dynamic update is enabled by including an ``allow-update`` or an
``update-policy`` clause in the ``zone`` statement.

If the zone's ``update-policy`` is set to ``local``, updates to the zone
will be permitted for the key ``local-ddns``, which will be generated by
``named`` at startup. See `Dynamic Update
Policies <#dynamic_update_policies>`__ for more details.

Dynamic updates using Kerberos signed requests can be made using the
TKEY/GSS protocol by setting either the ``tkey-gssapi-keytab`` option,
or alternatively by setting both the ``tkey-gssapi-credential`` and
``tkey-domain`` options. Once enabled, Kerberos signed requests will be
matched against the update policies for the zone, using the Kerberos
principal as the signer for the request.

Updating of secure zones (zones using DNSSEC) follows RFC 3007: RRSIG,
NSEC and NSEC3 records affected by updates are automatically regenerated
by the server using an online zone key. Update authorization is based on
transaction signatures and an explicit server policy.

.. _journal:

The journal file
~~~~~~~~~~~~~~~~

All changes made to a zone using dynamic update are stored in the zone's
journal file. This file is automatically created by the server when the
first dynamic update takes place. The name of the journal file is formed
by appending the extension ``.jnl`` to the name of the corresponding
zone file unless specifically overridden. The journal file is in a
binary format and should not be edited manually.

The server will also occasionally write ("dump") the complete contents
of the updated zone to its zone file. This is not done immediately after
each dynamic update, because that would be too slow when a large zone is
updated frequently. Instead, the dump is delayed by up to 15 minutes,
allowing additional updates to take place. During the dump process,
transient files will be created with the extensions ``.jnw`` and
``.jbk``; under ordinary circumstances, these will be removed when the
dump is complete, and can be safely ignored.

When a server is restarted after a shutdown or crash, it will replay the
journal file to incorporate into the zone any updates that took place
after the last zone dump.

Changes that result from incoming incremental zone transfers are also
journaled in a similar way.

The zone files of dynamic zones cannot normally be edited by hand
because they are not guaranteed to contain the most recent dynamic
changes â€” those are only in the journal file. The only way to ensure
that the zone file of a dynamic zone is up to date is to run
``rndc stop``.

If you have to make changes to a dynamic zone manually, the following
procedure will work: Disable dynamic updates to the zone using
``rndc freeze zone``. This will update the zone's master file with the
changes stored in its ``.jnl`` file. Edit the zone file. Run
``rndc thaw zone`` to reload the changed zone and re-enable dynamic
updates.

``rndc sync zone`` will update the zone file with changes from the
journal file without stopping dynamic updates; this may be useful for
viewing the current zone state. To remove the ``.jnl`` file after
updating the zone file, use ``rndc sync -clean``.

.. _incremental_zone_transfers:

Incremental Zone Transfers (IXFR)
---------------------------------

The incremental zone transfer (IXFR) protocol is a way for slave servers
to transfer only changed data, instead of having to transfer the entire
zone. The IXFR protocol is specified in RFC 1995. See `Proposed
Standards <#proposed_standards>`__.

When acting as a master, BIND 9 supports IXFR for those zones where the
necessary change history information is available. These include master
zones maintained by dynamic update and slave zones whose data was
obtained by IXFR. For manually maintained master zones, and for slave
zones obtained by performing a full zone transfer (AXFR), IXFR is
supported only if the option ``ixfr-from-differences`` is set to
``yes``.

When acting as a slave, BIND 9 will attempt to use IXFR unless it is
explicitly disabled. For more information about disabling IXFR, see the
description of the ``request-ixfr`` clause of the ``server`` statement.

.. _split_dns:

Split DNS
---------

Setting up different views, or visibility, of the DNS space to internal
and external resolvers is usually referred to as a *Split DNS* setup.
There are several reasons an organization would want to set up its DNS
this way.

One common reason for setting up a DNS system this way is to hide
"internal" DNS information from "external" clients on the Internet.
There is some debate as to whether or not this is actually useful.
Internal DNS information leaks out in many ways (via email headers, for
example) and most savvy "attackers" can find the information they need
using other means. However, since listing addresses of internal servers
that external clients cannot possibly reach can result in connection
delays and other annoyances, an organization may choose to use a Split
DNS to present a consistent view of itself to the outside world.

Another common reason for setting up a Split DNS system is to allow
internal networks that are behind filters or in RFC 1918 space (reserved
IP space, as documented in RFC 1918) to resolve DNS on the Internet.
Split DNS can also be used to allow mail from outside back in to the
internal network.

.. _split_dns_sample:

Example split DNS setup
~~~~~~~~~~~~~~~~~~~~~~~

Let's say a company named *Example, Inc.* (``example.com``) has several
corporate sites that have an internal network with reserved Internet
Protocol (IP) space and an external demilitarized zone (DMZ), or
"outside" section of a network, that is available to the public.

*Example, Inc.* wants its internal clients to be able to resolve
external hostnames and to exchange mail with people on the outside. The
company also wants its internal resolvers to have access to certain
internal-only zones that are not available at all outside of the
internal network.

In order to accomplish this, the company will set up two sets of name
servers. One set will be on the inside network (in the reserved IP
space) and the other set will be on bastion hosts, which are "proxy"
hosts that can talk to both sides of its network, in the DMZ.

The internal servers will be configured to forward all queries, except
queries for ``site1.internal``, ``site2.internal``,
``site1.example.com``, and ``site2.example.com``, to the servers in the
DMZ. These internal servers will have complete sets of information for
``site1.example.com``, ``site2.example.com``, ``site1.internal``, and
``site2.internal``.

To protect the ``site1.internal`` and ``site2.internal`` domains, the
internal name servers must be configured to disallow all queries to
these domains from any external hosts, including the bastion hosts.

The external servers, which are on the bastion hosts, will be configured
to serve the "public" version of the ``site1`` and ``site2.example.com``
zones. This could include things such as the host records for public
servers (``www.example.com`` and ``ftp.example.com``), and mail exchange
(MX) records (``a.mx.example.com`` and ``b.mx.example.com``).

In addition, the public ``site1`` and ``site2.example.com`` zones should
have special MX records that contain wildcard (`*') records pointing to
the bastion hosts. This is needed because external mail servers do not
have any other way of looking up how to deliver mail to those internal
hosts. With the wildcard records, the mail will be delivered to the
bastion host, which can then forward it on to internal hosts.

Here's an example of a wildcard MX record:

::

   *   IN MX 10 external1.example.com.

Now that they accept mail on behalf of anything in the internal network,
the bastion hosts will need to know how to deliver mail to internal
hosts. In order for this to work properly, the resolvers on the bastion
hosts will need to be configured to point to the internal name servers
for DNS resolution.

Queries for internal hostnames will be answered by the internal servers,
and queries for external hostnames will be forwarded back out to the DNS
servers on the bastion hosts.

In order for all this to work properly, internal clients will need to be
configured to query *only* the internal name servers for DNS queries.
This could also be enforced via selective filtering on the network.

If everything has been set properly, *Example, Inc.*'s internal clients
will now be able to:

-  Look up any hostnames in the ``site1`` and ``site2.example.com``
   zones.

-  Look up any hostnames in the ``site1.internal`` and
   ``site2.internal`` domains.

-  Look up any hostnames on the Internet.

-  Exchange mail with both internal and external people.

Hosts on the Internet will be able to:

-  Look up any hostnames in the ``site1`` and ``site2.example.com``
   zones.

-  Exchange mail with anyone in the ``site1`` and ``site2.example.com``
   zones.

Here is an example configuration for the setup we just described above.
Note that this is only configuration information; for information on how
to configure your zone files, see `Sample
Configurations <#sample_configuration>`__.

Internal DNS server config:

::


   acl internals { 172.16.72.0/24; 192.168.1.0/24; };

   acl externals { bastion-ips-go-here; };

   options {
       ...
       ...
       forward only;
       // forward to external servers
       forwarders {
       bastion-ips-go-here;
       };
       // sample allow-transfer (no one)
       allow-transfer { none; };
       // restrict query access
       allow-query { internals; externals; };
       // restrict recursion
       allow-recursion { internals; };
       ...
       ...
   };

   // sample master zone
   zone "site1.example.com" {
     type master;
     file "m/site1.example.com";
     // do normal iterative resolution (do not forward)
     forwarders { };
     allow-query { internals; externals; };
     allow-transfer { internals; };
   };

   // sample slave zone
   zone "site2.example.com" {
     type slave;
     file "s/site2.example.com";
     masters { 172.16.72.3; };
     forwarders { };
     allow-query { internals; externals; };
     allow-transfer { internals; };
   };

   zone "site1.internal" {
     type master;
     file "m/site1.internal";
     forwarders { };
     allow-query { internals; };
     allow-transfer { internals; }
   };

   zone "site2.internal" {
     type slave;
     file "s/site2.internal";
     masters { 172.16.72.3; };
     forwarders { };
     allow-query { internals };
     allow-transfer { internals; }
   };

External (bastion host) DNS server config:

::

   acl internals { 172.16.72.0/24; 192.168.1.0/24; };

   acl externals { bastion-ips-go-here; };

   options {
     ...
     ...
     // sample allow-transfer (no one)
     allow-transfer { none; };
     // default query access
     allow-query { any; };
     // restrict cache access
     allow-query-cache { internals; externals; };
     // restrict recursion
     allow-recursion { internals; externals; };
     ...
     ...
   };

   // sample slave zone
   zone "site1.example.com" {
     type master;
     file "m/site1.foo.com";
     allow-transfer { internals; externals; };
   };

   zone "site2.example.com" {
     type slave;
     file "s/site2.foo.com";
     masters { another_bastion_host_maybe; };
     allow-transfer { internals; externals; }
   };

In the ``resolv.conf`` (or equivalent) on the bastion host(s):

::

   search ...
   nameserver 172.16.72.2
   nameserver 172.16.72.3
   nameserver 172.16.72.4

TSIG
----

TSIG (Transaction SIGnatures) is a mechanism for authenticating DNS
messages, originally specified in RFC 2845. It allows DNS messages to be
cryptographically signed using a shared secret. TSIG can be used in any
DNS transaction, as a way to restrict access to certain server functions
(e.g., recursive queries) to authorized clients when IP-based access
control is insufficient or needs to be overridden, or as a way to ensure
message authenticity when it is critical to the integrity of the server,
such as with dynamic UPDATE messages or zone transfers from a master to
a slave server.

This is a guide to setting up TSIG in BIND. It describes the
configuration syntax and the process of creating TSIG keys.

``named`` supports TSIG for server-to-server communication, and some of
the tools included with BIND support it for sending messages to
``named``:

-  supports TSIG via the
   -k
   ,
   -l
   and
   -y
   command line options, or via the
   key
   command when running interactively.
-  supports TSIG via the
   -k
   and
   -y
   command line options.

Generating a Shared Key
~~~~~~~~~~~~~~~~~~~~~~~

TSIG keys can be generated using the ``tsig-keygen`` command; the output
of the command is a ``key`` directive suitable for inclusion in
``named.conf``. The key name, algorithm and size can be specified by
command line parameters; the defaults are "tsig-key", HMAC-SHA256, and
256 bits, respectively.

Any string which is a valid DNS name can be used as a key name. For
example, a key to be shared between servers called *host1* and *host2*
could be called "host1-host2.", and this key could be generated using:

::

     $ tsig-keygen host1-host2. > host1-host2.key

This key may then be copied to both hosts. The key name and secret must
be identical on both hosts. (Note: copying a shared secret from one
server to another is beyond the scope of the DNS. A secure transport
mechanism should be used: secure FTP, SSL, ssh, telephone, encrypted
email, etc.)

``tsig-keygen`` can also be run as ``ddns-confgen``, in which case its
output includes additional configuration text for setting up dynamic DNS
in ``named``. See `??? <#man.ddns-confgen>`__ for details.

Loading A New Key
~~~~~~~~~~~~~~~~~

For a key shared between servers called *host1* and *host2*, the
following could be added to each server's ``named.conf`` file:

::

   key "host1-host2." {
       algorithm hmac-sha256;
       secret "DAopyf1mhCbFVZw7pgmNPBoLUq8wEUT7UuPoLENP2HY=";
   };

(This is the same key generated above using ``tsig-keygen``.)

Since this text contains a secret, it is recommended that either
``named.conf`` not be world-readable, or that the ``key`` directive be
stored in a file which is not world-readable, and which is included in
``named.conf`` via the ``include`` directive.

Once a key has been added to ``named.conf`` and the server has been
restarted or reconfigured, the server can recognize the key. If the
server receives a message signed by the key, it will be able to verify
the signature. If the signature is valid, the response will be signed
using the same key.

TSIG keys that are known to a server can be listed using the command
``rndc tsig-list``.

Instructing the Server to Use a Key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A server sending a request to another server must be told whether to use
a key, and if so, which key to use.

For example, a key may be specified for each server in the ``masters``
statement in the definition of a slave zone; in this case, all SOA QUERY
messages, NOTIFY messages, and zone transfer requests (AXFR or IXFR)
will be signed using the specified key. Keys may also be specified in
the ``also-notify`` statement of a master or slave zone, causing NOTIFY
messages to be signed using the specified key.

Keys can also be specified in a ``server`` directive. Adding the
following on *host1*, if the IP address of *host2* is 10.1.2.3, would
cause *all* requests from *host1* to *host2*, including normal DNS
queries, to be signed using the ``host1-host2.`` key:

::

   server 10.1.2.3 {
       keys { host1-host2. ;};
   };

Multiple keys may be present in the ``keys`` statement, but only the
first one is used. As this directive does not contain secrets, it can be
used in a world-readable file.

Requests sent by *host2* to *host1* would *not* be signed, unless a
similar ``server`` directive were in *host2*'s configuration file.

Whenever any server sends a TSIG-signed DNS request, it will expect the
response to be signed with the same key. If a response is not signed, or
if the signature is not valid, the response will be rejected.

TSIG-Based Access Control
~~~~~~~~~~~~~~~~~~~~~~~~~

TSIG keys may be specified in ACL definitions and ACL directives such as
``allow-query``, ``allow-transfer`` and ``allow-update``. The above key
would be denoted in an ACL element as ``key host1-host2.``

An example of an ``allow-update`` directive using a TSIG key:

::

   allow-update { !{ !localnets; any; }; key host1-host2. ;};

This allows dynamic updates to succeed only if the UPDATE request comes
from an address in ``localnets``, *and* if it is signed using the
``host1-host2.`` key.

See `Dynamic Update Policies <#dynamic_update_policies>`__ for a
discussion of the more flexible ``update-policy`` statement.

Errors
~~~~~~

Processing of TSIG-signed messages can result in several errors:

-  If a TSIG-aware server receives a message signed by an unknown key,
   the response will be unsigned, with the TSIG extended error code set
   to BADKEY.
-  If a TSIG-aware server receives a message from a known key but with
   an invalid signature, the response will be unsigned, with the TSIG
   extended error code set to BADSIG.
-  If a TSIG-aware server receives a message with a time outside of the
   allowed range, the response will be signed, with the TSIG extended
   error code set to BADTIME, and the time values will be adjusted so
   that the response can be successfully verified.

In all of the above cases, the server will return a response code of
NOTAUTH (not authenticated).

TKEY
----

TKEY (Transaction KEY) is a mechanism for automatically negotiating a
shared secret between two hosts, originally specified in RFC 2930.

There are several TKEY "modes" that specify how a key is to be generated
or assigned. BIND 9 implements only one of these modes: Diffie-Hellman
key exchange. Both hosts are required to have a KEY record with
algorithm DH (though this record is not required to be present in a
zone).

The TKEY process is initiated by a client or server by sending a query
of type TKEY to a TKEY-aware server. The query must include an
appropriate KEY record in the additional section, and must be signed
using either TSIG or SIG(0) with a previously established key. The
server's response, if successful, will contain a TKEY record in its
answer section. After this transaction, both participants will have
enough information to calculate a shared secret using Diffie-Hellman key
exchange. The shared secret can then be used by to sign subsequent
transactions between the two servers.

TSIG keys known by the server, including TKEY-negotiated keys, can be
listed using ``rndc tsig-list``.

TKEY-negotiated keys can be deleted from a server using
``rndc tsig-delete``. This can also be done via the TKEY protocol
itself, by sending an authenticated TKEY query specifying the "key
deletion" mode.

SIG(0)
------

BIND partially supports DNSSEC SIG(0) transaction signatures as
specified in RFC 2535 and RFC 2931. SIG(0) uses public/private keys to
authenticate messages. Access control is performed in the same manner as
TSIG keys; privileges can be granted or denied in ACL directives based
on the key name.

When a SIG(0) signed message is received, it will only be verified if
the key is known and trusted by the server. The server will not attempt
to recursively fetch or validate the key.

SIG(0) signing of multiple-message TCP streams is not supported.

The only tool shipped with BIND 9 that generates SIG(0) signed messages
is ``nsupdate``.

.. _DNSSEC:

DNSSEC
------

Cryptographic authentication of DNS information is possible through the
DNS Security (*DNSSEC-bis*) extensions, defined in RFC 4033, RFC 4034,
and RFC 4035. This section describes the creation and use of DNSSEC
signed zones.

In order to set up a DNSSEC secure zone, there are a series of steps
which must be followed. BIND 9 ships with several tools that are used in
this process, which are explained in more detail below. In all cases,
the ``-h`` option prints a full list of parameters. Note that the DNSSEC
tools require the keyset files to be in the working directory or the
directory specified by the ``-d`` option, and that the tools shipped
with BIND 9.2.x and earlier are not compatible with the current ones.

There must also be communication with the administrators of the parent
and/or child zone to transmit keys. A zone's security status must be
indicated by the parent zone for a DNSSEC capable resolver to trust its
data. This is done through the presence or absence of a ``DS`` record at
the delegation point.

For other servers to trust data in this zone, they must either be
statically configured with this zone's zone key or the zone key of
another zone above this one in the DNS tree.

.. _dnssec_keys:

Generating Keys
~~~~~~~~~~~~~~~

The ``dnssec-keygen`` program is used to generate keys.

A secure zone must contain one or more zone keys. The zone keys will
sign all other records in the zone, as well as the zone keys of any
secure delegated zones. Zone keys must have the same name as the zone, a
name type of ``ZONE``, and must be usable for authentication. It is
recommended that zone keys use a cryptographic algorithm designated as
"mandatory to implement" by the IETF; currently the are two algorithms:
RSASHA256 and ECDSAP256SHA256. ECDSAP256SHA256 is recommended for
current and future deployments.

The following command will generate a ECDSAP256SHA256 key for the
``child.example`` zone:

``dnssec-keygen -a ECDSAP256SHA256 -n ZONE child.example.``

Two output files will be produced: ``Kchild.example.+013+12345.key`` and
``Kchild.example.+013+12345.private`` (where 12345 is an example of a
key tag). The key filenames contain the key name (``child.example.``),
algorithm (5 is RSASHA1, 8 is RSASHA256, 13 is ECDSAP256SHA256, 15 is
ED25519 etc.), and the key tag (12345 in this case). The private key (in
the ``.private`` file) is used to generate signatures, and the public
key (in the ``.key`` file) is used for signature verification.

To generate another key with the same properties (but with a different
key tag), repeat the above command.

The ``dnssec-keyfromlabel`` program is used to get a key pair from a
crypto hardware and build the key files. Its usage is similar to
``dnssec-keygen``.

The public keys should be inserted into the zone file by including the
``.key`` files using ``$INCLUDE`` statements.

.. _dnssec_signing:

Signing the Zone
~~~~~~~~~~~~~~~~

The ``dnssec-signzone`` program is used to sign a zone.

Any ``keyset`` files corresponding to secure sub-zones should be
present. The zone signer will generate ``NSEC``, ``NSEC3`` and ``RRSIG``
records for the zone, as well as ``DS`` for the child zones if ``'-g'``
is specified. If ``'-g'`` is not specified, then DS RRsets for the
secure child zones need to be added manually.

The following command signs the zone, assuming it is in a file called
``zone.child.example``. By default, all zone keys which have an
available private key are used to generate signatures.

``dnssec-signzone -o child.example zone.child.example``

One output file is produced: ``zone.child.example.signed``. This file
should be referenced by ``named.conf`` as the input file for the zone.

``dnssec-signzone`` will also produce a keyset and dsset files and
optionally a dlvset file. These are used to provide the parent zone
administrators with the ``DNSKEYs`` (or their corresponding ``DS``
records) that are the secure entry point to the zone.

.. _dnssec_config:

Configuring Servers for DNSSEC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To enable ``named`` to validate answers received from other servers, the
``dnssec-validation`` option must be set to either ``yes`` or ``auto``.

When ``dnssec-validation`` is set to ``auto``, a trust anchor for the
DNS root zone will automatically be used. This trust anchor is provided
as part of BIND and is kept up to date using RFC 5011 key management.

When ``dnssec-validation`` is set to ``yes``, DNSSEC validation will
only occur if at least one trust anchor has been explicitly configured
in ``named.conf`` using a ``trusted-keys`` or ``managed-keys``
statement.

When ``dnssec-validation`` is set to ``no``, DNSSEC validation will not
occur.

The default is ``auto`` unless BIND is built with
``configure --disable-auto-validation``, in which case the default is
``yes``.

``trusted-keys`` are copies of DNSKEY RRs for zones that are used to
form the first link in the cryptographic chain of trust. All keys listed
in ``trusted-keys`` (and corresponding zones) are deemed to exist and
only the listed keys will be used to validated the DNSKEY RRset that
they are from.

``managed-keys`` are trusted keys which are automatically kept up to
date via RFC 5011 trust anchor maintenance.

``trusted-keys`` and ``managed-keys`` are described in more detail later
in this document.

Unlike BIND 8, BIND 9 does not verify signatures on load, so zone keys
for authoritative zones do not need to be specified in the configuration
file.

After DNSSEC gets established, a typical DNSSEC configuration will look
something like the following. It has one or more public keys for the
root. This allows answers from outside the organization to be validated.
It will also have several keys for parts of the namespace the
organization controls. These are here to ensure that ``named`` is immune
to compromises in the DNSSEC components of the security of parent zones.

::

   managed-keys {
       /* Root Key */
       "." initial-key 257 3 3 "BNY4wrWM1nCfJ+CXd0rVXyYmobt7sEEfK3clRbGaTwS
                    JxrGkxJWoZu6I7PzJu/E9gx4UC1zGAHlXKdE4zYIpRh
                    aBKnvcC2U9mZhkdUpd1Vso/HAdjNe8LmMlnzY3zy2Xy
                    4klWOADTPzSv9eamj8V18PHGjBLaVtYvk/ln5ZApjYg
                    hf+6fElrmLkdaz MQ2OCnACR817DF4BBa7UR/beDHyp
                    5iWTXWSi6XmoJLbG9Scqc7l70KDqlvXR3M/lUUVRbke
                    g1IPJSidmK3ZyCllh4XSKbje/45SKucHgnwU5jefMtq
                    66gKodQj+MiA21AfUVe7u99WzTLzY3qlxDhxYQQ20FQ
                    97S+LKUTpQcq27R7AT3/V5hRQxScINqwcz4jYqZD2fQ
                    dgxbcDTClU0CRBdiieyLMNzXG3";
   };

   trusted-keys {
       /* Key for our organization's forward zone */
       example.com. 257 3 5 "AwEAAaxPMcR2x0HbQV4WeZB6oEDX+r0QM6
                     5KbhTjrW1ZaARmPhEZZe3Y9ifgEuq7vZ/z
                     GZUdEGNWy+JZzus0lUptwgjGwhUS1558Hb
                     4JKUbbOTcM8pwXlj0EiX3oDFVmjHO444gL
                     kBOUKUf/mC7HvfwYH/Be22GnClrinKJp1O
                     g4ywzO9WglMk7jbfW33gUKvirTHr25GL7S
                     TQUzBb5Usxt8lgnyTUHs1t3JwCY5hKZ6Cq
                     FxmAVZP20igTixin/1LcrgX/KMEGd/biuv
                     F4qJCyduieHukuY3H4XMAcR+xia2nIUPvm
                     /oyWR8BW/hWdzOvnSCThlHf3xiYleDbt/o
                     1OTQ09A0=";

       /* Key for our reverse zone. */
       2.0.192.IN-ADDRPA.NET. 257 3 5 "AQOnS4xn/IgOUpBPJ3bogzwc
                          xOdNax071L18QqZnQQQAVVr+i
                          LhGTnNGp3HoWQLUIzKrJVZ3zg
                          gy3WwNT6kZo6c0tszYqbtvchm
                          gQC8CzKojM/W16i6MG/eafGU3
                          siaOdS0yOI6BgPsw+YZdzlYMa
                          IJGf4M4dyoKIhzdZyQ2bYQrjy
                          Q4LB0lC7aOnsMyYKHHYeRvPxj
                          IQXmdqgOJGq+vsevG06zW+1xg
                          YJh9rCIfnm1GX/KMgxLPG2vXT
                          D/RnLX+D3T3UL7HJYHJhAZD5L
                          59VvjSPsZJHeDCUyWYrvPZesZ
                          DIRvhDD52SKvbheeTJUm6Ehkz
                          ytNN2SN96QRk8j/iI8ib";
   };

   options {
       ...
       dnssec-validation yes;
   };

..

   **Note**

   None of the keys listed in this example are valid. In particular, the
   root key is not valid.

When DNSSEC validation is enabled and properly configured, the resolver
will reject any answers from signed, secure zones which fail to
validate, and will return SERVFAIL to the client.

Responses may fail to validate for any of several reasons, including
missing, expired, or invalid signatures, a key which does not match the
DS RRset in the parent zone, or an insecure response from a zone which,
according to its parent, should have been secure.

   **Note**

   When the validator receives a response from an unsigned zone that has
   a signed parent, it must confirm with the parent that the zone was
   intentionally left unsigned. It does this by verifying, via signed
   and validated NSEC/NSEC3 records, that the parent zone contains no DS
   records for the child.

   If the validator *can* prove that the zone is insecure, then the
   response is accepted. However, if it cannot, then it must assume an
   insecure response to be a forgery; it rejects the response and logs
   an error.

   The logged error reads "insecurity proof failed" and "got insecure
   response; parent indicates it should be secure".

.. _ipv6:

IPv6 Support in BIND 9
----------------------

BIND 9 fully supports all currently defined forms of IPv6 name to
address and address to name lookups. It will also use IPv6 addresses to
make queries when running on an IPv6 capable system.

For forward lookups, BIND 9 supports only AAAA records. RFC 3363
deprecated the use of A6 records, and client-side support for A6 records
was accordingly removed from BIND 9. However, authoritative BIND 9 name
servers still load zone files containing A6 records correctly, answer
queries for A6 records, and accept zone transfer for a zone containing
A6 records.

For IPv6 reverse lookups, BIND 9 supports the traditional "nibble"
format used in the *ip6.arpa* domain, as well as the older, deprecated
*ip6.int* domain. Older versions of BIND 9 supported the "binary label"
(also known as "bitstring") format, but support of binary labels has
been completely removed per RFC 3363. Many applications in BIND 9 do not
understand the binary label format at all any more, and will return an
error if given. In particular, an authoritative BIND 9 name server will
not load a zone file containing binary labels.

For an overview of the format and structure of IPv6 addresses, see `IPv6
addresses (AAAA) <#ipv6addresses>`__.

Address Lookups Using AAAA Records
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The IPv6 AAAA record is a parallel to the IPv4 A record, and, unlike the
deprecated A6 record, specifies the entire IPv6 address in a single
record. For example,

::

   $ORIGIN example.com.
   host            3600    IN      AAAA    2001:db8::1

Use of IPv4-in-IPv6 mapped addresses is not recommended. If a host has
an IPv4 address, use an A record, not a AAAA, with
``::ffff:192.168.42.1`` as the address.

Address to Name Lookups Using Nibble Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When looking up an address in nibble format, the address components are
simply reversed, just as in IPv4, and ``ip6.arpa.`` is appended to the
resulting name. For example, the following would provide reverse name
lookup for a host with address ``2001:db8::1``.

::

   $ORIGIN 0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa.
   1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0  14400   IN    PTR    (
                       host.example.com. )

